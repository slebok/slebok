this is BabyCOBOL
CSS is ../www/babycobol.css
logo is ../www/babycobol.png

source CLIST is IBM SA32-0978-00, z/OS TSO/E CLISTs Version 2 Release 1, 1988–2013
source REXX is IBM SA32-0982-00, z/OS TSO/E REXX User's Guide Version 2 Release 1, 1988–2013
source FORTRAN is The FORTRAN Automatic Coding System for the IBM 704 EDPM, October 15, 1956
source COBOL is IBM SC23-8528-01, Enterprise COBOL for z/OS Language Reference Version 4 Release 2, 1991–2009
source RPG is IBM SC09-2508-09, IBM i Version 7.2, Programming IBM Rational Development Studio for i ILE RPG Reference, 1994–2013

  ////  // //  ///      //   ////    //  //  ////   //   ///   ////  /// 
 ///   /////  ////    ////  ///     //////  ///   ////  ////  ///   ////
////  // //  ///      //   //      //  //  ////  ////  ///   ////  // //
statement CLIST.ATTN became SIGNAL
summary: define a handler for an attention interrupt

statement CLIST.CLOSFILE
summary: close a previously opened QSAM file

statement CLIST.CONTROL
summary: define processing options

statement CLIST.DATA
summary: statements for TSO/E to execute

statement CLIST.DATA_PROMPT
summary: respond to prompts by TSO/E commands

statement CLIST.DO became LOOP
summary: execute a sequence of commands repeatedly

statement CLIST.END became END
summary: end DO, SELECT or a procedure

statement CLIST.ERROR became SIGNAL
summary: check for non-zero return codes of other commands

statement CLIST.EXIT became STOP
summary: terminate the program

statement CLIST.GETFILE
summary: read a record from a QSAM file

statement CLIST.GLOBAL
summary: share values between nested programs

statement CLIST.NGLOBAL
summary: share values between procedures within a program

statement CLIST.GOTO became GO_TO
summary: branch unconditionally within a program

statement CLIST.IF became IF
summary: branch conditionally within a program

statement CLIST.LISTDSI
summary: get information about a dataset

statement CLIST.OPENFILE
summary: open a QSAM file for input and output

statement CLIST.PROC became SECTION
summary: define a procedure

statement CLIST.PUTFILE
summary: write a record to a QSAM file

statement CLIST.READ became ACCEPT
summary: read user input and store it in variables

statement CLIST.READDVAL
summary: read a &SYSDVAL control variable

statement CLIST.RETURN
summary: return from an error handler or a procedure

statement CLIST.SELECT became EVALUATE
summary: branch to multiple locations based on several conditions

statement CLIST.SET became MOVE
summary: assign a value to a variable

statement CLIST.SYSCALL became PERFORM
summary: call a local procedure

statement CLIST.SYSREF
summary: define which caller's data can a procedure access

statement CLIST.TERMIN
summary: temporary pass control to the terminal user

statement CLIST.TERMING
summary: temporary pass control to the terminal user from a nested program

statement CLIST.WRITE became DISPLAY
summary: display text on the terminal

statement CLIST.WRITENR became DISPLAY
summary: display text on the terminal without advancing a cursor to the next line

statement CLIST.EXEC became CALL
summary: call another program

  ////  // //  ///      //   ////    ////  //    //  ////  //////
 ///   /////  ////    ////  ///     //    //    //  ////    //
////  // //  ///      //   //      ////  ////  //  ////    //
statement REXX.ADDRESS became ALTER
summary: change the destination of commands

statement REXX.ARG
summary: syntactic sugar for PARSE UPPER ARG

statement REXX.CALL became CALL
summary: call a built-in or external function

statement REXX.CALL_ON became SIGNAL
summary: change an error handler

statement REXX.CALL_OFF became SIGNAL
summary: cancel an established error handler

statement REXX.DO became LOOP
summary: execute a group of instructions repeatedly

statement REXX.DROP
summary: unassign a named variable

statement REXX.EXIT became STOP
summary: terminate a program

statement REXX.IF became IF
summary: branch conditionally within a program

statement REXX.INTERPRET
summary: execute an expression as code

// continue from a loop
statement REXX.ITERATE
summary: go into the next iteration of the innermost or named DO loop

// break
statement REXX.LEAVE
summary: terminate the innermost or named DO loop

statement REXX.NOP became NEXT_SENTENCE
summary: do nothing

statement REXX.NUMERIC
summary: specify numeric conventions: significant digits, notation format, etc

statement REXX.OPTIONS
summary: change DBCS strings treatment

statement REXX.PARSE
summary: parsing in a broad sense

statement REXX.PROCEDURE
summary: protect variables by making them local (otherwise all are global)

statement REXX.PULL became ACCEPT
summary: syntactic sugar for PARSE UPPER PULL

statement REXX.PUSH
summary: LIFO output

statement REXX.QUEUE
summary: FIFO output

statement REXX.RETURN became STOP
summary: terminates a procedure or the program if no procedure is active

statement REXX.SAY became DISPLAY
summary: display a line on the terminal

statement REXX.SELECT became EVALUATE
summary: branch to multiple locations based on several conditions

statement REXX.SIGNAL became GO_TO
summary: branch unconditionally within a program

statement REXX.SIGNAL_ON became SIGNAL
summary: define a handler for a specific condition

statement REXX.SIGNAL_OFF became SIGNAL
summary: cancel an established error handler

statement REXX.TRACE
summary: perform debugging actions

statement REXX.UPPER
summary: makes contents of a variable uppercase

statement REXX.PARSE_SOURCE
summary: read files and access other sources

  ////  // //  ///      //   ////    ///    ////  ////  ////
 ///   /////  ////    ////  ///     ////   ///    //    //
////  // //  ///      //   //      // //  ////  ////  ////
statement COBOL.ACCEPT became ACCEPT
summary: accept user data as the new value of an identifier
statement COBOL.ADD became ADD
summary: sum two or more numeric operands
statement COBOL.ALTER became ALTER
summary: change the transfer point of an existing GO TO statement
statement COBOL.CALL
summary: transfer control from one program to another
statement COBOL.CANCEL
summary: clear the state of a called subprogram
statement COBOL.CLOSE
summary: revoke access to a file or volume
statement COBOL.COMPUTE
summary: assign a variable with a result of a computation of an expression
statement COBOL.CONTINUE became NEXT_SENTENCE
summary: do nothing
statement COBOL.DELETE
summary: remove a record from a file or statements from the program under compilation
statement COBOL.DISPLAY became DISPLAY
summary: print contents of data fields on the display
statement COBOL.DIVIDE became DIVIDE
summary: divide one numeric operand into others
statement COBOL.ENTRY
summary: specify a different entry point for a program
statement COBOL.EVALUATE became EVALUATE
summary: shorthand notation for a series of nested IF statements
statement COBOL.EXIT became NEXT_SENTENCE
summary: do nothing
statement COBOL.EXIT_METHOD
summary: terminate the execution of a method
statement COBOL.EXIT_PROGRAM became STOP
summary: terminate the execution of a subprogram
statement COBOL.GOBACK became STOP
summary: act like an EXIT PROGRAM or like a STOP RUN
statement COBOL.GO_TO became GO_TO
summary: branch unconditionally to another section or paragraph
statement COBOL.IF became IF
summary: branch conditionally within a program
statement COBOL.INITIALIZE
summary: assign default values to data fields
statement COBOL.INSPECT
summary: count or convert characters in a string
statement COBOL.INVOKE
summary: create object instances and call methods
statement COBOL.MERGE
summary: combine two or more files
statement COBOL.MOVE became MOVE
summary: transfer data from one storage area to another
statement COBOL.MULTIPLY became MULTIPLY
summary: multiply numeric values
statement COBOL.NEXT_SENTENCE became NEXT_SENTENCE
summary: a special clause of the IF statement to transfer control to the statement after the next dot
statement COBOL.OPEN
summary: initiates file processing
statement COBOL.PERFORM_(in-line) became LOOP
summary: execute a list of statements repeatedly
statement COBOL.PERFORM_(out-of-line) became PERFORM
summary: call a local procedure
statement COBOL.READ
summary: read the next record from an opened file
statement COBOL.RELEASE
summary: prepare data for sorting
statement COBOL.RETURN
summary: transfer sorted or merged records to the output
statement COBOL.REWRITE
summary: replace an existing record in a file
statement COBOL.SEARCH
summary: search a table for an element satisfying the given condition
statement COBOL.SET
summary: perform specific assignments
statement COBOL.SORT
summary: sort records from one or more files
statement COBOL.START
summary: adjust the cursor position in a file
statement COBOL.STOP_RUN became STOP
summary: terminate the program
statement COBOL.STRING became DISPLAY
summary: format and concatenate strings
statement COBOL.SUBTRACT became SUBTRACT
summary: subtract one or more numeric values from another value
statement COBOL.UNSTRING
summary: split data over several data fields
statement COBOL.WRITE
summary: add a record to a file or another output
statement COBOL.XML
summary: convert data to or from XML
statement COBOL.BASIS
summary: a directive to provide a program to compile
statement COBOL.CBL
summary: a directive to specify compilation options
statement COBOL.PROCESS
summary: a directive to specify compilation options
statement COBOL.*CONTROL
summary: a directive to select what is being printed during compilation
statement COBOL.*CBL
summary: a directive to select what is being printed during compilation
statement COBOL.COPY became COPY
summary: a directive to include another file
statement COBOL.EJECT
summary: a directive to use a new page when printing the listing
statement COBOL.ENTER
summary: a directive to support compilation of programs written in other languages than COBOL
statement COBOL.INSERT
summary: a directive to add source code lines to the basis program
statement COBOL.READY_TRACE
summary: a directive to activate the debugging mode
statement COBOL.RESET_TRACE
summary: a directive to reset the debugging mode
statement COBOL.REPLACE became COPY
summary: a directive to switch ongoing replacements on or off
statement COBOL.SERVICE
summary: directives inserted by CICS
statement COBOL.SKIP
summary: a directive to add blank source code lines to the listing
statement COBOL.TITLE
summary: a directive to specify a page title to print the listing
statement COBOL.USE became SIGNAL
summary: a directive to activate debugging or exception handling

  ////  // //  ///      //   ////    ////  /////  ////  /////  //
 ///   /////  ////    ////  ///     //    // //  ////  // //  //
////  // //  ///      //   //      ////  /////  ////  /////  ////

statement FORTRAN.GO_TO became GO_TO
summary: branch unconditionally within a program (unconditional, assigned, computed)

statement FORTRAN.IF became IF
summary: branch conditionally within a program, if the value is less than, equal to, or greater than zero

statement FORTRAN.SENSE_LIGHT
summary: switch sense lights on the 704 console on or off

statement FORTRAN.PAUSE
summary: temporary terminate the program

statement FORTRAN.STOP became STOP
summary: definitively terminate the program

statement FORTRAN.DO became LOOP
summary: execute a statement repeatedly

statement FORTRAN.CONTINUE became NEXT_SENTENCE
summary: do nothing

statement FORTRAN.FORMAT became DISPLAY
summary: prepare data for printing

statement FORTRAN.READ became ACCEPT
summary: accepts data from input cards, tape or drum

statement FORTRAN.PUNCH
summary: punch cards

statement FORTRAN.PRINT became DISPLAY
summary: display data according to the given format

statement FORTRAN.WRITE
summary: write data to a tape or a drum

statement FORTRAN.END_FILE
summary: write an end of file marker on tape

statement FORTRAN.REWIND
summary: rewind a tape unit

statement FORTRAN.BACKSPACE
summary: make the tape step back one record

statement FORTRAN.DIMENSION
summary: provide data sizes for memory allocation

statement FORTRAN.EQUIVALENCE
summary: define which data structures are allowed to reuse each others' memory

statement FORTRAN.FREQUENCY
summary: provide an estimation of how often which lines will be executed

statement FORTRAN.ASSIGN became ALTER
summary: change the target of an assigned GO TO statement

statement FORTRAN.CALL became PERFORM
summary: invoke a subroutine

statement FORTRAN.RETURN became STOP
summary: terminate a subprogram and return control to the calling program unit

  ////  // //  ///      //   ////    ////  /////  ///  //////  ///    //   /// //
 ///   /////  ////    ////  ///     ///   // //  ////   //    ////  ////  //////
////  // //  ///      //   //      //    /////  // //  //    // // ////  // ///

statement RPG.ACQ
summary: acquire a program device
statement RPG.ADD became ADD
summary: add two numbers together
statement RPG.ADDDUR
summary: add duration to a date/time/timestamp
statement RPG.ALLOC
summary: allocate storage in the heap
statement RPG.AND
summary: combine two conditions with a conjunction
statement RPG.BEGSR
summary: begin a subrouting
statement RPG.BITOFF
summary: assign some bits to zeroes
statement RPG.BITON
summary: assign some bits to ones
statement RPG.CAB became IF
summary: branch conditionally within a program
statement RPG.CALL
summary: transfer control to another program
statement RPG.CALLB
summary: transfer control to a bound procedure
statement RPG.CALLP
summary: transfer control to a prototyped procedure or program
statement RPG.CAS became PERFORM
summary: conditionally invoke subroutine
statement RPG.CAT
summary: concatenate two strings
statement RPG.CHAIN
summary: fetch a record from a file
statement RPG.CHECK
summary: verify that a string contains only allowed characters
statement RPG.CHECKR
summary: verify that a string contains only allowed characters, in reverse
statement RPG.CLEAR
summary: assign default values to a structure
statement RPG.CLOSE
summary: close one or more files or devices and disconnects them
statement RPG.COMMIT
summary: commit to scheduled changes
statement RPG.COMP
summary: compare two values and set appropriate indicators
statement RPG.DATA-INTO became ACCEPT
summary: parse a document into a variable
statement RPG.DEALLOC
summary: free one allocation of heap storage
// TODO: DEFINE = DATA DIVISION?
statement RPG.DEFINE
summary: define a data field
statement RPG.DELETE
summary: delete a record from a database file
statement RPG.DIV became DIVIDE
summary: divide a number by another number
statement RPG.DO became LOOP
summary: execute a group of operations several times
statement RPG.DOU became LOOP
summary: execute a group of operations until a condition is met
statement RPG.DOW became LOOP
summary: execute a group of operations while a condition holds
statement RPG.DSPLY became DISPLAY
summary: display a message
statement RPG.DUMP
summary: provide a full dump of the executed module
statement RPG.ELSE became IF
summary: the optional part of an IF or IFxx operator
statement RPG.ELSEIF became IF
summary: a combination of ELSE and IF
statement RPG.END became END
summary: a family of operations ending a CASxx, DO, DOU, DOUxx, DOW, DOWxx, FOR, IF, IFxx or SELECT operation
statement RPG.EVAL
summary: evaluate an expression
statement RPG.EVALR
summary: evaluate an expression and place is right-adjusted into the result
statement RPG.EVAL-CORR became MOVE
summary: evaluate an expression and assign corresponding subfields
statement RPG.EXCEPT
summary: write one or more records during detail calculations or total calculations
statement RPG.EXFMT
summary: a combination of WRITE and READ
statement RPG.EXSR became PERFORM
summary: invoke a local subroutine
statement RPG.EXTRCT
summary: extract date or time details from a timestamp
statement RPG.FEOD
summary: signal the forced end of data
statement RPG.FOR became LOOP
summary: iterate over a group of operations
statement RPG.FORCE
summary: select from which file will the next read happen
statement RPG.GOTO became GO_TO
summary: branch unconditionally within a program
statement RPG.IF
summary: conditionally execute a series of operations
statement RPG.IN
summary: retrieve a data area
statement RPG.ITER
summary: forces an outer loop to proceed to the next iteration
statement RPG.KFLD
summary: designate a field as a part of a search argument
statement RPG.KLIST
summary: create a named search argument from a list of fields
statement RPG.LEAVE
summary: terminate an outer loop prematurely
statement RPG.LEAVESR
summary: exit a subroutine
statement RPG.LOOKUP
summary: search for an element in an array or table
statement RPG.MxxZO
summary: move zone portions of characters
statement RPG.MONITOR became SIGNAL
summary: perform error handling based on the status code
statement RPG.MOVE became MOVE
summary: move character data
statement RPG.MOVEA became MOVE
summary: move data between arrays
statement RPG.MOVEL became MOVE
summary: move character data starting from the leftmost one
statement RPG.MULT became MULTIPLY
summary: multiply two numbers
statement RPG.MVR became DIVIDE
summary: calculate a reminder of a division
statement RPG.NEXT
summary: schedules the next READ/CHAIN/... operation to read from a particular source
// NB: same as BabyCOBOL OCCURS
statement RPG.OCCUR
summary: specify the occurrence of a data structure
statement RPG.ON-ERROR became SIGNAL
summary: specify which error conditions trigger the handler
statement RPG.ON-EXIT
summary: specify code that is run every time a subroutine is terminated
statement RPG.OPEN
summary: open a file for processing
statement RPG.OR
summary: combine two conditions with a disjunction
statement RPG.OTHER became EVALUATE
summary: define a branch in a SELECT group to be executed if no WHEN condition matches
statement RPG.OUT
summary: update a data area
statement RPG.PARM
summary: define parameters in a parameter list
statement RPG.PLIST
summary: identify a parameter list for a CALL/CALLB
statement RPG.POST
summary: fill in a file information data structure (INFDS)
statement RPG.READ
summary: read a record from a full procedural file
statement RPG.READC
summary: read the next changed record from a WORKSTN file
statement RPG.READE
summary: read a record from a full procedural file with a known key or EOF otherwise
statement RPG.READP
summary: read a prior record from a full procedural file
statement RPG.READPE
summary: read the next prior sequential record from a full procedural file with a known key or EOF otherwise
statement RPG.REALLOC
summary: reallocate storage with new length
statement RPG.REL
summary: release the block on a program device
statement RPG.RESET
summary: restore a variable to its default value
statement RPG.RETURN
summary: return to caller
statement RPG.ROLBK
summary: roll back — eliminates all changes to all files since the last rollback or commit
statement RPG.SCAN
summary: find a substring in a string
statement RPG.SELECT became EVALUATE
summary: branch to multiple locations based on several conditions
statement RPG.SETGT
summary: position a file at a record with a key greater than the given value
statement RPG.SETLL
summary: position a file at a record with a key greater or equal than the given value
statement RPG.SETOFF
summary: set off all indicators from positions 71–76
statement RPG.SETON
summary: set on all indicators from positions 71–76
statement RPG.SHTDN
summary: check whether the system operator has requested a system shutdown
statement RPG.SORTA
summary: sort an array
statement RPG.SQRT
summary: calculate square root of expression
statement RPG.SUB became SUBTRACT
summary: subtract one number from another number
statement RPG.SUBDUR
summary: subtract duration from a date/time/timestamp
statement RPG.SUBST
summary: carve a substring from a string
statement RPG.TAG
summary: define a label to use with GO TO
statement RPG.TEST
summary: test the validity of a date/time/timestamp
statement RPG.TESTB
summary: compare operands bitwise
statement RPG.TESTN
summary: find zoned decimal digits within a string
statement RPG.TESTZ
summary: test the zone of the leftmost character in a string
statement RPG.TIME
summary: retrieve date/time/timestamp
statement RPG.UNLOCK
summary: release record locks and unlock a data area
statement RPG.UPDATE
summary: modify an existing record
statement RPG.WHEN became EVALUATE
summary: define a branch within a SELECT block
statement RPG.WRITE
summary: create new records
statement RPG.XFOOT
summary: sum all elements of an array
statement RPG.XLATE
summary: translate a string according to a given mapping
statement RPG.XML-INTO
summary: parse an XML document into a variable
statement RPG.XML-SAX
summary: initiate reactive parsing of an XML document into a variable
statement RPG.Z-ADD became ADD
summary: add a number to a field of zeroes
statement RPG.Z-SUB became SUBTRACT
summary: subtract a number from a field of zeroes

  ////  // //  ///      //   ////    ///    ////  ////
 ///   /////  ////    ////  ///     ////   ////  // _
////  // //  ///      //   //      // //  //    ////

statement PL/I.CALL became PERFORM
summary: invoke a local subroutine
statement PL/I.RETURN
summary: terminate execution of a subroutine or a function procedure
statement PL/I.OPTIONS
summary: annotate a package, procedure, entry or a statement block with metadata
statement PL/I.PROCEDURE
summary: define a local callable procedure
statement PL/I.ALLOCATE
summary: allocate storage for controlled variables
statement PL/I.ATTACH
summary: create a new thread
statement PL/I.BEGIN
summary: start a block of statements
statement PL/I.CLOSE
summary: dissociate a file from its data set
statement PL/I.DECLARE
statement PL/I.DEFINE
statement PL/I.DEFAULT
statement PL/I.DELAY
statement PL/I.DELETE
statement PL/I.DETACH
statement PL/I.DISPLAY
statement PL/I.DO became LOOP
statement PL/I.END became УТВ
statement PL/I.ENTRY
statement PL/I.EXIT
statement PL/I.FETCH
statement PL/I.FLUSH
summary: flush buffers associated with an output file
statement PL/I.FORMAT
statement PL/I.FREE
statement PL/I.GET
statement PL/I.GO_TO became GO_TO
statement PL/I.IF became IF
statement PL/I.%INCLUDE became COPY
statement PL/I.ITERATE
statement PL/I.LEAVE
statement PL/I.%LINE
statement PL/I.LOCATE
statement PL/I.%NOPRINT
statement PL/I.%NOTE
statement PL/I.; became NEXT_SENTENCE
statement PL/I.ON
statement PL/I.OPEN
summary: associate a file with a data set
statement PL/I.OTHERWISE became EVALUATE
statement PL/I.PACKAGE
statement PL/I.%PAGE
statement PL/I.%POP
statement PL/I.%PRINT
statement PL/I.%PROCESS
statement PL/I.*PROCESS
statement PL/I.%PUSH
statement PL/I.PUT
statement PL/I.READ
statement PL/I.RELEASE
statement PL/I.RESIGNAL
statement PL/I.REVERT
statement PL/I.REWRITE
statement PL/I.SELECT
statement PL/I.SIGNAL
statement PL/I.%SKIP
statement PL/I.STOP
statement PL/I.WAIT
statement PL/I.WHEN became EVALUATE
statement PL/I.WRITE
statement PL/I.%XINCLUDE

  ////  // //  ///      //   ////    ////  //      //  //
 ///   /////  ////    ////  ///     ////  //     //   //
////  // //  ///      //   //      //    ////  //    //

statement BabyCOBOL.ACCEPT
summary: read user input and store it in variables
format: [17:] >> - "ACCEPT" - - Identifier - ^7 - ><
remarks: <ul><li>the input is expected to obey the picture clause definition of the data fields being read</li></ul>

statement BabyCOBOL.ADD
summary: add two or more values together
format: [33:] >> - "ADD" - - Atomic - ^5 - "TO" - Atomic - #1 -12 >< &1 \ "GIVING" - Identifier /
remarks: <ul><li>all three arguments obey the rules of sufficient qualification</li><li>either of the first two arguments can be a literal</li><li>if the second argument is a literal, the third argument is mandatory</li><li>any of the three arguments can be an identifier defined with a numeric picture clause (free from <code>A</code> and <code>X</code>)</li></ul>

statement BabyCOBOL.ALTER
summary: change the target of a GO TO statement
format: [32.] >> - "ALTER" - ProcedureName - "TO" "PROCEED" "TO" - ProcedureName - ><

statement BabyCOBOL.COPY
summary: insert contents from a different file
format: [37,] >> - "COPY" - FileName - #1 -22 >< &1 \2 "REPLACING" -2 Literal - "BY" - Literal - ^13 /2
remarks: <ul><li>argument literals are quoted with <code>===</code> on each side, like this: <code>COPY REPLACING ===XXX=== BY ===YYY===</code></li></ul>

statement BabyCOBOL.DISPLAY
summary: display text on the terminal
format: [40:] >> - "DISPLAY" -2 Atomic - "DELIMITED_BY" - #2 - "SIZE" -3 #3 &2 \ "SPACE" / &3 ^18 - #4 -12 >< &4 \ "WITH_NO_ADVANCING" /
remarks: <ul><li><code>WITH NO ADVANCING</code> clause prints the text without appending newline character(s)</li><li>values <code>DELIMITED BY SPACE</code> are printed by converting them to strings and trimming empty spaces from both sides</li><li>values <code>DELIMITED BY SIZE</code> are printed by converting them to strings of fixed size corresponding to their defined (identifiers) or inferred (literals) type</li></ul>

statement BabyCOBOL.DIVIDE
summary: divide a numeric value by other numbers
format: [50:] >> - "DIVIDE" - Atomic - "INTO" - - Atomic - ^5 - #1 -12 #2 -15 >< &1 \ "GIVING" - Identifier / &2 \ "REMAINDER" - Identifier /
remarks: <ul><li>all four arguments obey the rules of sufficient qualification</li><li>either of the first two arguments can be a literal</li><li>if the first argument is a literal, the third argument is mandatory</li><li>any of the four arguments can be an identifier defined with a numeric picture clause (free from <code>A</code> and <code>X</code>)</li></ul>

statement BabyCOBOL.EVALUATE
summary: branch to multiple locations based on several conditions
format: [41\] >> - "EVALUATE" - AnyExpression - #1 -20 "END" - >< &1 \2 "WHEN" - #2 -2 Atomic - ^5 -3 Sentence - ^6 /2 &2 \ - "OTHER" - /

statement BabyCOBOL.GO_TO
summary: branch unconditionally within a program
format: [17.] >> - "GO_TO" - ProcedureName - ><
// todo: the CC paper also included GO TO ... OR ...
remarks: <ul><li>branching outside an active <code>LOOP</code> terminates its iteration</li><li>branching outside paragraphs being <code>PERFORM</code>ed terminates the performance and forfeits the call place, acting as a redirected return</li><li>the argument can be a field name, possibly being reassigned at runtime with <code>MOVE</code></li></ul>

statement BabyCOBOL.IF
summary: branch conditionally within a program
format: [47,] >> - "IF" - BooleanExpression - "THEN" -2 Statement - ^7 - #1 -13 #2 -6 >< &1 \2 "ELSE" -2 Statement - ^7 /2 &2 \ "END" /
remarks: <ul><li>an <code>END</code>-less <code>IF</code> is terminated at the end of the sentence (by <code>.</code>)</li></ul>

statement BabyCOBOL.LOOP
summary: structural execution of a sequence of commands
format: [55⇓] >> - "LOOP" - #0 -44 "END" - >< &0 \2 - #1 - "VARYING" - #2 -8 #3 -9 #4 -8 #5 -8 - ^41 /2 &2 \ Identifier / &3 \ "FROM" - Atomic / &4 \ "TO" - Atomic / &5 \ "BY" - Atomic / &1 \3 "WHILE" - BooleanExpression -25 &1 \4 "UNTIL" - BooleanExpression -25 &1 \5 Statement -32 /5

statement BabyCOBOL.MOVE
summary: partial structural assignment
format: [26\] >> - "MOVE" - #1 - Atomic -5 "TO" -2 Identifier - ^7 - >< &1 \ "HIGH-VALUES" - &1 \2 "LOW-VALUES" -2 &1 \3 "SPACES" -3 /3
remarks: <ul><li>for numeric fields (defined with picture clauses without <code>A</code> nor <code>X</code>), BabyCOBOL's <code>MOVE SPACES</code> behaves like COBOL's <code>MOVE ZEROES</code></li><li>if the first argument is an identifier, BabyCOBOL's <code>MOVE</code> behaves like COBOL's <code>MOVE CORRESPONDING</code></li><li>if the first argument is a figurative value, it can lead to assigning vastly different values to second arguments depending on their individual types</li></ul>

statement BabyCOBOL.MULTIPLY
summary: multiply two or more numeric values
format: [33:] >> - "MULTIPLY" - Atomic - "BY" -2 Atomic - ^5 - #1 -12 >< &1 \ "GIVING" - Identifier /
remarks: <ul><li>all three arguments obey the rules of sufficient qualification</li><li>either of the first two arguments can be a literal</li><li>if the second argument is a literal, the third argument is mandatory</li><li>any of the three arguments can be an identifier defined with a numeric picture clause (free from <code>A</code> and <code>X</code>)</li></ul>

statement BabyCOBOL.NEXT_SENTENCE
summary: branch unconditionally to the beginning of the next sentence
format: [13.] >> - "NEXT_SENTENCE" - ><
syntax: The syntax of this statement is very straightforward, and hides only one subtlety: watch out for the dot after it. If there is a dot, as in "<code>NEXT SENTENCE.</code>", then the entire statement becomes meaningless and does nothing, since it is supposed to transfer control to the beginning of the next sentence, and dot ends the current sentence and signals the immediate start of the next one. So, the NEXT SENTENCE statement with a dot just represents and empty statement, called "no operation" elsewhere, while the NEXT SENTENCE without a dot works as defined below. So while in COBOL the NEXT SENTENCE statement can only be used as a special clause inside an IF statement, in BabyCOBOL it can be used anywhere, including facilitating an empty paragraph (which technically cannot be empty, but will exhibit no noticeable behaviour if only contains a dotted NEXT SENTENCE statement), similar to the role EXIT plays in COBOL.
semantics: The problems of implementing the NEXT SENTENCE statement come from the clash between the hierarchical tree-like structure of the program and its flat textual structure. The official semantics of the NEXT SENTENCE statement is that it: <ul><li>Transfers control to the first statement of the next sentence (after the dot)</li><li>If the transfer takes the execution away from the current context of LOOP, PERFORM, etc, cleans up call stack contents, temporary variables and other local effects of the context being left behind</li></ul> If the AST already incorporates the information about sentences in addition to statements, then implementing the NEXT SENTENCE statement should not be too difficult: we need to prepare a possibly useful target label at the beginning of each sentence, and use it when needed. Due to BabyCOBOL's simplified design, this is the only possible way in the language to essentially GO TO within a paragraph.
style: NEXT SENTENCE at the beginning of the paragraph can be used to comment out one of more of the immediately following statements, making them dead code without marking each line as an explicit comment.

statement BabyCOBOL.PERFORM
summary: call a paragraph or section within the program
format: [42.] >> - "PERFORM" - ProcedureName - #1 -15 #2 -10 >< &1 \ "THROUGH" - ProcedureName / &2 \ Atomic - "TIMES" /

statement BabyCOBOL.SIGNAL
summary: specify an error handler
format: [24:] >> - "SIGNAL" - #1 - ProcedureName -2 "ON_ERROR" - >< &1 \ "OFF" -5 /

statement BabyCOBOL.STOP
summary: terminate the program
format: [7.] >> - "STOP" - ><

statement BabyCOBOL.SUBTRACT
summary: subtract one or more numeric values from another value
format: [34:] >> - "SUBTRACT" -2 Atomic - ^5 - "FROM" - Atomic - #1 -12 >< &1 \ "GIVING" - Identifier /
remarks: <ul><li>all three arguments obey the rules of sufficient qualification</li><li>either of the first two arguments can be a literal</li><li>if the second argument is a literal, the third argument is mandatory</li><li>any of the three arguments can be an identifier defined with a numeric picture clause (free from <code>A</code> and <code>X</code>)</li></ul>

// TODO: other things like HIGH-VALUES